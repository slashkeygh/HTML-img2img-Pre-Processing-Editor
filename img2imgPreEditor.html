<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>img2img Pre-Processing Editor with Frame Extraction</title>
    <!-- v1.01 by Slashkey Studio - Socials: github.com/users/slashkeygh/projects/ - patreon.com/slashkey - youtube.com/@slashkeystudio - x.com/SlashkeyStudio -->
    <style>
        .container {
            display: flex;
            height: 100vh;
        }
        .settings-menu {
            width: 300px;
            padding: 10px;
            background: #f0f0f0;
            overflow-y: auto;
        }
        .content-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: #e0e0e0;
        }
        .tabs {
            display: flex;
            background: #ddd;
            padding: 5px;
        }
        .tab {
            padding: 10px;
            cursor: pointer;
            background: #ccc;
            margin-right: 5px;
        }
        .tab.active {
            background: #fff;
            font-weight: bold;
        }
        .tab-content {
            flex: 1;
            display: none;
            justify-content: center;
            align-items: center;
            position: relative;
        }
        .tab-content.active {
            display: flex;
        }
        #mainCanvas, #videoCanvas {
            max-width: 100%;
            max-height: 100%;
        }
        .drop-zone {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            border: 2px dashed #666;
            padding: 20px;
            background: rgba(255, 255, 255, 0.8);
            cursor: pointer;
        }
        .drop-zone.dragover {
            background: #ccc;
        }
        .color-swatch {
            width: 20px;
            height: 20px;
            display: inline-block;
            margin: 2px;
            cursor: pointer;
        }
        label {
            display: block;
            margin: 5px 0;
        }
        #historyList, #frameList {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #ccc;
            padding: 5px;
        }
        #videoControls {
            position: absolute;
            bottom: 10px;
            width: 100%;
            text-align: center;
        }
        .slider-container {
            display: flex;
            align-items: center;
        }
        .slider-container input[type="range"] {
            flex: 1;
            margin-right: 5px;
        }
        .slider-container input[type="number"] {
            width: 60px;
        }
        .bottom-buttons {
            margin-top: 20px;
            text-align: center;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="settings-menu">
            <h2>Settings</h2>
            <div id="imageSettings">
                <label><input type="checkbox" id="liveUpdates" checked> Live Updates</label>
                <button id="undoBtn" disabled>Undo</button>
                <button id="saveBtn">Save</button>
                <button id="saveAsBtn">Save As...</button>
                <button id="resetBtn">Reset</button>
                <button id="closeImageBtn">Close</button>
                <h3>History</h3>
                <div id="historyList"></div>
                <hr>
                <h3>Image</h3>
                <p>Original: <span id="originalInfo"></span></p>
                <label>Width: <input type="number" id="width" min="1" value="512"></label>
                <label>Height: <input type="number" id="height" min="1" value="512"></label>
                <label><input type="checkbox" id="keepAspectRatio" checked> Keep Aspect Ratio</label>
                <div class="slider-container">
                    <label>Brightness:</label>
                    <input type="range" id="brightness" min="-100" max="100" value="0">
                    <input type="number" id="brightnessValue" min="-100" max="100" value="0">
                </div>
                <div class="slider-container">
                    <label>Sharpen:</label>
                    <input type="range" id="sharpen" min="0" max="2" step="0.1" value="0">
                    <input type="number" id="sharpenValue" min="0" max="2" step="0.1" value="0">
                </div>
                <h3>Adjustments</h3>
                <div class="slider-container">
                    <label>Saturation:</label>
                    <input type="range" id="saturation" min="-100" max="100" value="0">
                    <input type="number" id="saturationValue" min="-100" max="100" value="0">
                </div>
                <div class="slider-container">
                    <label>Contrast:</label>
                    <input type="range" id="contrast" min="-100" max="100" value="0">
                    <input type="number" id="contrastValue" min="-100" max="100" value="0">
                </div>
                <div class="slider-container">
                    <label>Highlights:</label>
                    <input type="range" id="highlights" min="-100" max="100" value="0">
                    <input type="number" id="highlightsValue" min="-100" max="100" value="0">
                </div>
                <div class="slider-container">
                    <label>Shadows:</label>
                    <input type="range" id="shadows" min="-100" max="100" value="0">
                    <input type="number" id="shadowsValue" min="-100" max="100" value="0">
                </div>
                <div class="slider-container">
                    <label>Hue Shift:</label>
                    <input type="range" id="hueShift" min="-180" max="180" value="0">
                    <input type="number" id="hueShiftValue" min="-180" max="180" value="0">
                </div>
                <label><input type="checkbox" id="greyscaleToggle"> Greyscale</label>
                <hr>
                <h3>Blur</h3>
                <div class="slider-container">
                    <label>Blur:</label>
                    <input type="range" id="blur" min="0" max="20" step="0.1" value="0">
                    <input type="number" id="blurValue" min="0" max="20" step="0.1" value="0">
                </div>
                <hr>
                <h3>Noise</h3>
                <label><input type="checkbox" id="noiseEnabled"> Enable Noise</label>
                <label><input type="checkbox" id="uniformRGB"> Uniform RGB</label>
                <div class="slider-container">
                    <label>R:</label>
                    <input type="range" id="noiseR" min="0" max="100" value="0">
                    <input type="number" id="noiseRValue" min="0" max="100" value="0">
                </div>
                <div class="slider-container">
                    <label>G:</label>
                    <input type="range" id="noiseG" min="0" max="100" value="0">
                    <input type="number" id="noiseGValue" min="0" max="100" value="0">
                </div>
                <div class="slider-container">
                    <label>B:</label>
                    <input type="range" id="noiseB" min="0" max="100" value="0">
                    <input type="number" id="noiseBValue" min="0" max="100" value="0">
                </div>
                <div class="slider-container">
                    <label>Noise Size:</label>
                    <input type="range" id="noiseSize" min="1" max="100" value="1">
                    <input type="number" id="noiseSizeValue" min="1" max="100" value="1">
                </div>
                <div class="slider-container">
                    <label>Noise Blur:</label>
                    <input type="range" id="noiseBlur" min="0" max="10" step="0.1" value="0">
                    <input type="number" id="noiseBlurValue" min="0" max="10" step="0.1" value="0">
                </div>
                <hr>
                <h3>Color Overlay</h3>
                <label>Color: <input type="color" id="overlayColor" value="#ff0000"></label>
                <div class="slider-container">
                    <label>Opacity:</label>
                    <input type="range" id="overlayOpacity" min="0" max="100" value="0">
                    <input type="number" id="overlayOpacityValue" min="0" max="100" value="0">
                </div>
                <div>
                    <div>Main Colors:</div>
                    <div id="mainColors"></div>
                    <div>Skintones:</div>
                    <div id="skintones"></div>
                </div>
                <hr>
                <h3>Shapes Overlay</h3>
                <label><input type="checkbox" id="shapesEnabled"> Enable Shapes</label>
                <div class="slider-container">
                    <label>Count:</label>
                    <input type="range" id="shapesCount" min="0" max="100" value="0">
                    <input type="number" id="shapesCountValue" min="0" max="100" value="0">
                </div>
                <label>Color: <input type="color" id="shapesColor" value="#0000ff"></label>
                <div class="slider-container">
                    <label>Size:</label>
                    <input type="range" id="shapesSize" min="1" max="200" value="50">
                    <input type="number" id="shapesSizeValue" min="1" max="200" value="50">
                </div>
                <label><input type="checkbox" id="shapesRandomSize"> Random Size</label>
                <label><input type="checkbox" id="shapesRandomRotation"> Random Rotation</label>
                <div class="slider-container">
                    <label>Opacity:</label>
                    <input type="range" id="shapesOpacity" min="0" max="100" value="100">
                    <input type="number" id="shapesOpacityValue" min="0" max="100" value="100">
                </div>
                <label>
                    Shapes:
                    <input type="checkbox" id="shapesCircle" checked> Circle
                    <input type="checkbox" id="shapesSquare"> Square
                    <input type="checkbox" id="shapesTriangle"> Triangle
                </label>
                <label><input type="checkbox" id="shapesRandomColorSimilar"> Random Color - Similar</label>
                <label><input type="checkbox" id="shapesRandomColorTrue"> Random Color - True Random</label>
                <label><input type="checkbox" id="shapesRandomOpacity"> Random Opacity</label>
                <div class="slider-container">
                    <label>Shapes Blur:</label>
                    <input type="range" id="shapesBlur" min="0" max="20" step="0.1" value="0">
                    <input type="number" id="shapesBlurValue" min="0" max="20" step="0.1" value="0">
                </div>
                <h4>Grid Settings</h4>
                <label><input type="checkbox" id="shapesGridEnabled"> Enable Grid</label>
                <label>Columns: <input type="number" id="shapesGridCols" min="1" max="50" value="5"></label>
                <label>Rows: <input type="number" id="shapesGridRows" min="1" max="50" value="5"></label>
                <hr>
                <h3>Darken Lines</h3>
                <label><input type="checkbox" id="darkenLinesEnabled"> Enable Darken Lines</label>
                <div class="slider-container">
                    <label>Threshold:</label>
                    <input type="range" id="darkenThreshold" min="0" max="255" value="200">
                    <input type="number" id="darkenThresholdValue" min="0" max="255" value="200">
                </div>
                <div class="slider-container">
                    <label>Layers:</label>
                    <input type="range" id="darkenLayers" min="1" max="10" value="1">
                    <input type="number" id="darkenLayersValue" min="1" max="10" value="1">
                </div>
                <hr>
                <h3>Pixelization</h3>
                <div class="slider-container">
                    <label>Pixel Size:</label>
                    <input type="range" id="pixelSize" min="1" max="50" step="1" value="1">
                    <input type="number" id="pixelSizeValue" min="1" max="50" step="1" value="1">
                </div>
                <hr>
                <h3>Tools</h3>
                <label><input type="radio" name="tool" value="none" checked> None</label>
                <label><input type="radio" name="tool" value="bucket"> Bucket Fill</label>
                <label><input type="radio" name="tool" value="paintbrush"> Paintbrush</label>
                <div id="bucketSettings" style="display:none;">
                    <label>Color: <input type="color" id="bucketColor" value="#00ff00"></label>
                    <div class="slider-container">
                        <label>Threshold:</label>
                        <input type="range" id="bucketThreshold" min="0" max="100" value="10">
                        <input type="number" id="bucketThresholdValue" min="0" max="100" value="10">
                    </div>
                    <div class="slider-container">
                        <label>Opacity:</label>
                        <input type="range" id="bucketOpacity" min="0" max="100" value="100">
                        <input type="number" id="bucketOpacityValue" min="0" max="100" value="100">
                    </div>
                </div>
                <div id="paintbrushSettings" style="display:none;">
                    <label>Color: <input type="color" id="paintbrushColor" value="#000000"></label>
                    <div class="slider-container">
                        <label>Size:</label>
                        <input type="range" id="paintbrushSize" min="1" max="100" value="5">
                        <input type="number" id="paintbrushSizeValue" min="1" max="100" value="5">
                    </div>
                    <div class="slider-container">
                        <label>Opacity:</label>
                        <input type="range" id="paintbrushOpacity" min="0" max="100" value="100">
                        <input type="number" id="paintbrushOpacityValue" min="0" max="100" value="100">
                    </div>
                </div>
                <div class="bottom-buttons">
                    <button id="undoBottomBtn" disabled>Undo</button>
                </div>
            </div>
            <div id="frameSettings" style="display:none;">
                <h3>Frame Extraction</h3>
                <button id="chooseSaveDir">Choose Save Directory</button>
                <p id="saveDirInfo">No directory selected</p>
                <label><input type="checkbox" id="saveToDir" checked> Save to Directory</label>
                <button id="extractLastFrame">Extract Last Frame</button>
                <button id="extractAllFrames">Extract All Frames</button>
                <button id="closeVideoBtn">Close</button>
                <hr>
                <h4>Custom Extraction</h4>
                <label>Interval Type:
                    <select id="intervalType">
                        <option value="frame">Frame</option>
                        <option value="time">Time (seconds)</option>
                    </select>
                </label>
                <label>Interval: <input type="number" id="intervalValue" min="0.1" step="0.1" value="1"></label>
                <button id="extractInterval">Extract by Interval</button>
                <hr>
                <h4>Precise Selection</h4>
                <label>Frame: <input type="number" id="frameNumber" min="0" value="0"></label>
                <button id="extractCurrentFrame">Extract Current Frame</button>
                <h4>Extracted Frames</h4>
                <div id="frameList"></div>
            </div>
        </div>
        <div class="content-area">
            <div class="tabs">
                <div class="tab active" data-tab="image">Image Editor</div>
                <div class="tab" data-tab="frame">Frame Extraction</div>
            </div>
            <div class="tab-content active" id="imageTab">
                <canvas id="mainCanvas"></canvas>
                <div class="drop-zone" id="imageDropZone">Drag and drop or click to load image</div>
            </div>
            <div class="tab-content" id="frameTab">
                <video id="videoPlayer" controls style="max-width:100%; max-height:100%; display:none;"></video>
                <canvas id="videoCanvas" style="display:none;"></canvas>
                <div class="drop-zone" id="videoDropZone">Drag and drop or click to load MP4</div>
                <div id="videoControls" style="display:none;">
                    <input type="range" id="videoSeek" min="0" value="0" style="width:80%;">
                </div>
            </div>
        </div>
    </div>
    <canvas id="baseCanvas" style="display:none;"></canvas>
    <script>
        // Tab Switching
        const tabs = document.querySelectorAll('.tab');
        const tabContents = document.querySelectorAll('.tab-content');
        const imageSettings = document.getElementById('imageSettings');
        const frameSettings = document.getElementById('frameSettings');
        tabs.forEach(tab => {
            tab.addEventListener('click', () => {
                tabs.forEach(t => t.classList.remove('active'));
                tabContents.forEach(tc => tc.classList.remove('active'));
                tab.classList.add('active');
                document.getElementById(`${tab.dataset.tab}Tab`).classList.add('active');
                imageSettings.style.display = tab.dataset.tab === 'image' ? 'block' : 'none';
                frameSettings.style.display = tab.dataset.tab === 'frame' ? 'block' : 'none';
            });
        });

        // Image Editor Variables
        const baseCanvas = document.getElementById('baseCanvas');
        const mainCanvas = document.getElementById('mainCanvas');
        const ctx = mainCanvas.getContext('2d');
        const baseCtx = baseCanvas.getContext('2d');
        const imageDropZone = document.getElementById('imageDropZone');
        let originalImage = null;
        let originalImageData = null;
        let history = [];
        let shapesData = [];
        let isPainting = false;

        // Frame Extraction Variables
        const videoPlayer = document.getElementById('videoPlayer');
        const videoCanvas = document.getElementById('videoCanvas');
        const videoCtx = videoCanvas.getContext('2d');
        const videoDropZone = document.getElementById('videoDropZone');
        const videoSeek = document.getElementById('videoSeek');
        const extractLastFrame = document.getElementById('extractLastFrame');
        const extractAllFrames = document.getElementById('extractAllFrames');
        const intervalType = document.getElementById('intervalType');
        const intervalValue = document.getElementById('intervalValue');
        const extractInterval = document.getElementById('extractInterval');
        const frameNumber = document.getElementById('frameNumber');
        const extractCurrentFrame = document.getElementById('extractCurrentFrame');
        const frameList = document.getElementById('frameList');
        const chooseSaveDir = document.getElementById('chooseSaveDir');
        const saveDirInfo = document.getElementById('saveDirInfo');
        const saveToDir = document.getElementById('saveToDir');
        const closeVideoBtn = document.getElementById('closeVideoBtn');
        let videoLoaded = false;
        let frameRate = 30;
        let saveDirectoryHandle = null;

        const liveUpdates = document.getElementById('liveUpdates');
        const undoBtn = document.getElementById('undoBtn');
        const undoBottomBtn = document.getElementById('undoBottomBtn');
        const saveBtn = document.getElementById('saveBtn');
        const saveAsBtn = document.getElementById('saveAsBtn');
        const resetBtn = document.getElementById('resetBtn');
        const closeImageBtn = document.getElementById('closeImageBtn');
        const widthInput = document.getElementById('width');
        const heightInput = document.getElementById('height');
        const keepAspectRatio = document.getElementById('keepAspectRatio');
        const brightness = document.getElementById('brightness');
        const brightnessValue = document.getElementById('brightnessValue');
        const sharpen = document.getElementById('sharpen');
        const sharpenValue = document.getElementById('sharpenValue');
        const saturation = document.getElementById('saturation');
        const saturationValue = document.getElementById('saturationValue');
        const contrast = document.getElementById('contrast');
        const contrastValue = document.getElementById('contrastValue');
        const highlights = document.getElementById('highlights');
        const highlightsValue = document.getElementById('highlightsValue');
        const shadows = document.getElementById('shadows');
        const shadowsValue = document.getElementById('shadowsValue');
        const hueShift = document.getElementById('hueShift');
        const hueShiftValue = document.getElementById('hueShiftValue');
        const greyscaleToggle = document.getElementById('greyscaleToggle');
        const blurSlider = document.getElementById('blur');
        const blurValue = document.getElementById('blurValue');
        const noiseEnabled = document.getElementById('noiseEnabled');
        const uniformRGB = document.getElementById('uniformRGB');
        const noiseR = document.getElementById('noiseR');
        const noiseRValue = document.getElementById('noiseRValue');
        const noiseG = document.getElementById('noiseG');
        const noiseGValue = document.getElementById('noiseGValue');
        const noiseB = document.getElementById('noiseB');
        const noiseBValue = document.getElementById('noiseBValue');
        const noiseSize = document.getElementById('noiseSize');
        const noiseSizeValue = document.getElementById('noiseSizeValue');
        const noiseBlur = document.getElementById('noiseBlur');
        const noiseBlurValue = document.getElementById('noiseBlurValue');
        const overlayColor = document.getElementById('overlayColor');
        const overlayOpacity = document.getElementById('overlayOpacity');
        const overlayOpacityValue = document.getElementById('overlayOpacityValue');
        const shapesEnabled = document.getElementById('shapesEnabled');
        const shapesCount = document.getElementById('shapesCount');
        const shapesCountValue = document.getElementById('shapesCountValue');
        const shapesColor = document.getElementById('shapesColor');
        const shapesSize = document.getElementById('shapesSize');
        const shapesSizeValue = document.getElementById('shapesSizeValue');
        const shapesRandomSize = document.getElementById('shapesRandomSize');
        const shapesRandomRotation = document.getElementById('shapesRandomRotation');
        const shapesOpacity = document.getElementById('shapesOpacity');
        const shapesOpacityValue = document.getElementById('shapesOpacityValue');
        const shapesCircle = document.getElementById('shapesCircle');
        const shapesSquare = document.getElementById('shapesSquare');
        const shapesTriangle = document.getElementById('shapesTriangle');
        const shapesRandomColorSimilar = document.getElementById('shapesRandomColorSimilar');
        const shapesRandomColorTrue = document.getElementById('shapesRandomColorTrue');
        const shapesRandomOpacity = document.getElementById('shapesRandomOpacity');
        const shapesBlur = document.getElementById('shapesBlur');
        const shapesBlurValue = document.getElementById('shapesBlurValue');
        const shapesGridEnabled = document.getElementById('shapesGridEnabled');
        const shapesGridCols = document.getElementById('shapesGridCols');
        const shapesGridRows = document.getElementById('shapesGridRows');
        const darkenLinesEnabled = document.getElementById('darkenLinesEnabled');
        const darkenThreshold = document.getElementById('darkenThreshold');
        const darkenThresholdValue = document.getElementById('darkenThresholdValue');
        const darkenLayers = document.getElementById('darkenLayers');
        const darkenLayersValue = document.getElementById('darkenLayersValue');
        const bucketColor = document.getElementById('bucketColor');
        const bucketThreshold = document.getElementById('bucketThreshold');
        const bucketThresholdValue = document.getElementById('bucketThresholdValue');
        const bucketOpacity = document.getElementById('bucketOpacity');
        const bucketOpacityValue = document.getElementById('bucketOpacityValue');
        const paintbrushColor = document.getElementById('paintbrushColor');
        const paintbrushSize = document.getElementById('paintbrushSize');
        const paintbrushSizeValue = document.getElementById('paintbrushSizeValue');
        const paintbrushOpacity = document.getElementById('paintbrushOpacity');
        const paintbrushOpacityValue = document.getElementById('paintbrushOpacityValue');
        const pixelSize = document.getElementById('pixelSize');
        const pixelSizeValue = document.getElementById('pixelSizeValue');
        const historyList = document.getElementById('historyList');
        const mainColors = ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff', '#00ffff', '#000000', '#ffffff'];
        const skintones = ['#f1d4b5', '#e4b894', '#d89c6e', '#c87e4e', '#a65e2e'];
        const mainColorsDiv = document.getElementById('mainColors');
        const skintonesDiv = document.getElementById('skintones');
        mainColors.forEach(color => {
            const swatch = document.createElement('div');
            swatch.className = 'color-swatch';
            swatch.style.backgroundColor = color;
            swatch.onclick = () => overlayColor.value = color;
            mainColorsDiv.appendChild(swatch);
        });
        skintones.forEach(color => {
            const swatch = document.createElement('div');
            swatch.className = 'color-swatch';
            swatch.style.backgroundColor = color;
            swatch.onclick = () => overlayColor.value = color;
            skintonesDiv.appendChild(swatch);
        });

        // History Management
        function addToHistory(action, dataUrl) {
            history.push({ action, dataUrl });
            undoBtn.disabled = false;
            undoBottomBtn.disabled = false;
            const item = document.createElement('div');
            item.textContent = action;
            historyList.appendChild(item);
            historyList.scrollTop = historyList.scrollHeight;
        }

        function undo() {
            if (history.length <= 1) return;
            history.pop();
            const lastState = history[history.length - 1];
            const img = new Image();
            img.onload = () => {
                baseCanvas.width = img.width;
                baseCanvas.height = img.height;
                baseCtx.drawImage(img, 0, 0);
                render();
            };
            img.src = lastState.dataUrl;
            historyList.removeChild(historyList.lastChild);
            undoBtn.disabled = history.length <= 1;
            undoBottomBtn.disabled = history.length <= 1;
        }

        function resetImage() {
            if (!originalImageData) return;
            baseCanvas.width = originalImage.width;
            baseCanvas.height = originalImage.height;
            baseCtx.drawImage(originalImage, 0, 0);
            history = [{ action: 'Load Image', dataUrl: originalImageData }];
            historyList.innerHTML = '<div>Load Image</div>';
            undoBtn.disabled = true;
            undoBottomBtn.disabled = true;
            widthInput.value = originalImage.width;
            heightInput.value = originalImage.height;
            brightness.value = 0;
            brightnessValue.value = 0;
            sharpen.value = 0;
            sharpenValue.value = 0;
            saturation.value = 0;
            saturationValue.value = 0;
            contrast.value = 0;
            contrastValue.value = 0;
            highlights.value = 0;
            highlightsValue.value = 0;
            shadows.value = 0;
            shadowsValue.value = 0;
            hueShift.value = 0;
            hueShiftValue.value = 0;
            greyscaleToggle.checked = false;
            blurSlider.value = 0;
            blurValue.value = 0;
            noiseEnabled.checked = false;
            uniformRGB.checked = false;
            noiseR.value = 0;
            noiseRValue.value = 0;
            noiseG.value = 0;
            noiseGValue.value = 0;
            noiseB.value = 0;
            noiseBValue.value = 0;
            noiseSize.value = 1;
            noiseSizeValue.value = 1;
            noiseBlur.value = 0;
            noiseBlurValue.value = 0;
            overlayOpacity.value = 0;
            overlayOpacityValue.value = 0;
            shapesEnabled.checked = false;
            shapesCount.value = 0;
            shapesCountValue.value = 0;
            shapesSize.value = 50;
            shapesSizeValue.value = 50;
            shapesRandomSize.checked = false;
            shapesRandomRotation.checked = false;
            shapesOpacity.value = 100;
            shapesOpacityValue.value = 100;
            shapesRandomColorSimilar.checked = false;
            shapesRandomColorTrue.checked = false;
            shapesRandomOpacity.checked = false;
            shapesBlur.value = 0;
            shapesBlurValue.value = 0;
            shapesGridEnabled.checked = false;
            darkenLinesEnabled.checked = false;
            pixelSize.value = 1;
            pixelSizeValue.value = 1;
            bucketThreshold.value = 10;
            bucketThresholdValue.value = 10;
            bucketOpacity.value = 100;
            bucketOpacityValue.value = 100;
            paintbrushSize.value = 5;
            paintbrushSizeValue.value = 5;
            paintbrushOpacity.value = 100;
            paintbrushOpacityValue.value = 100;
            render();
        }

        function closeImage() {
            originalImage = null;
            originalImageData = null;
            history = [];
            historyList.innerHTML = '';
            undoBtn.disabled = true;
            undoBottomBtn.disabled = true;
            baseCanvas.width = 0;
            baseCanvas.height = 0;
            mainCanvas.width = 0;
            mainCanvas.height = 0;
            imageDropZone.style.display = 'block';
            document.getElementById('originalInfo').textContent = '';
        }

        function closeVideo() {
            videoLoaded = false;
            videoPlayer.src = '';
            videoPlayer.style.display = 'none';
            videoCanvas.style.display = 'none';
            videoControls.style.display = 'none';
            videoDropZone.style.display = 'block';
            frameList.innerHTML = '';
            saveDirectoryHandle = null;
            saveDirInfo.textContent = 'No directory selected';
        }

        // Image Loading
        function loadImage(file) {
            const reader = new FileReader();
            reader.onload = function(e) {
                const img = new Image();
                img.onload = function() {
                    originalImage = img;
                    originalImageData = e.target.result;
                    baseCanvas.width = img.width;
                    baseCanvas.height = img.height;
                    baseCtx.drawImage(img, 0, 0);
                    const gcd = (a, b) => b === 0 ? a : gcd(b, a % b);
                    const divisor = gcd(img.width, img.height);
                    document.getElementById('originalInfo').textContent = `${img.width}x${img.height} (${img.width / divisor}:${img.height / divisor})`;
                    widthInput.value = img.width;
                    heightInput.value = img.height;
                    history = [{ action: 'Load Image', dataUrl: baseCanvas.toDataURL() }];
                    historyList.innerHTML = '<div>Load Image</div>';
                    undoBtn.disabled = true;
                    undoBottomBtn.disabled = true;
                    imageDropZone.style.display = 'none';
                    render();
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        imageDropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            imageDropZone.classList.add('dragover');
        });
        imageDropZone.addEventListener('dragleave', () => imageDropZone.classList.remove('dragover'));
        imageDropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            imageDropZone.classList.remove('dragover');
            const file = e.dataTransfer.files[0];
            if (file && file.type.startsWith('image/')) loadImage(file);
        });
        imageDropZone.addEventListener('click', () => {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'image/*';
            input.onchange = (e) => loadImage(e.target.files[0]);
            input.click();
        });

        // Generate Persistent Shapes
        function generateShapes() {
            shapesData = [];
            if (!shapesEnabled.checked) return;
            const count = parseInt(shapesCount.value);
            const shapeTypes = [];
            if (shapesCircle.checked) shapeTypes.push('circle');
            if (shapesSquare.checked) shapeTypes.push('square');
            if (shapesTriangle.checked) shapeTypes.push('triangle');
            if (shapeTypes.length === 0 || count === 0) return;
            const width = parseInt(widthInput.value);
            const height = parseInt(heightInput.value);
            const baseSize = parseInt(shapesSize.value);

            if (shapesGridEnabled.checked) {
                const cols = parseInt(shapesGridCols.value);
                const rows = parseInt(shapesGridRows.value);
                const cellWidth = width / cols;
                const cellHeight = height / rows;
                for (let row = 0; row < rows; row++) {
                    for (let col = 0; col < cols; col++) {
                        const x = col * cellWidth + cellWidth / 2;
                        const y = row * cellHeight + cellHeight / 2;
                        const type = shapeTypes[Math.floor(Math.random() * shapeTypes.length)];
                        const size = shapesRandomSize.checked ? Math.random() * baseSize : baseSize;
                        let color = shapesColor.value;
                        if (shapesRandomColorSimilar.checked) {
                            const baseColor = hexToRgb(shapesColor.value);
                            const r = Math.max(0, Math.min(255, baseColor[0] + (Math.random() * 50 - 25)));
                            const g = Math.max(0, Math.min(255, baseColor[1] + (Math.random() * 50 - 25)));
                            const b = Math.max(0, Math.min(255, baseColor[2] + (Math.random() * 50 - 25)));
                            color = `rgb(${r}, ${g}, ${b})`;
                        } else if (shapesRandomColorTrue.checked) {
                            const r = Math.floor(Math.random() * 256);
                            const g = Math.floor(Math.random() * 256);
                            const b = Math.floor(Math.random() * 256);
                            color = `rgb(${r}, ${g}, ${b})`;
                        }
                        const rotation = shapesRandomRotation.checked ? Math.random() * 2 * Math.PI : 0;
                        let opacity = parseInt(shapesOpacity.value) / 100;
                        if (shapesRandomOpacity.checked) opacity *= Math.random();
                        shapesData.push({ type, x, y, size, color, rotation, opacity });
                    }
                }
            } else {
                for (let i = 0; i < count; i++) {
                    const type = shapeTypes[Math.floor(Math.random() * shapeTypes.length)];
                    const x = Math.random() * width;
                    const y = Math.random() * height;
                    const size = shapesRandomSize.checked ? Math.random() * baseSize : baseSize;
                    let color = shapesColor.value;
                    if (shapesRandomColorSimilar.checked) {
                        const baseColor = hexToRgb(shapesColor.value);
                        const r = Math.max(0, Math.min(255, baseColor[0] + (Math.random() * 50 - 25)));
                        const g = Math.max(0, Math.min(255, baseColor[1] + (Math.random() * 50 - 25)));
                        const b = Math.max(0, Math.min(255, baseColor[2] + (Math.random() * 50 - 25)));
                            color = `rgb(${r}, ${g}, ${b})`;
                    } else if (shapesRandomColorTrue.checked) {
                            const r = Math.floor(Math.random() * 256);
                            const g = Math.floor(Math.random() * 256);
                            const b = Math.floor(Math.random() * 256);
                            color = `rgb(${r}, ${g}, ${b})`;
                        }
                        const rotation = shapesRandomRotation.checked ? Math.random() * 2 * Math.PI : 0;
                        let opacity = parseInt(shapesOpacity.value) / 100;
                        if (shapesRandomOpacity.checked) opacity *= Math.random();
                        shapesData.push({ type, x, y, size, color, rotation, opacity });
                    }
                }
            }

            // Image Render Function
            function render() {
                if (!originalImage) {
                    ctx.clearRect(0, 0, mainCanvas.width, mainCanvas.height);
                    return;
                }
                const width = parseInt(widthInput.value);
                const height = parseInt(heightInput.value);
                mainCanvas.width = width;
                mainCanvas.height = height;

                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = baseCanvas.width;
                tempCanvas.height = baseCanvas.height;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.drawImage(baseCanvas, 0, 0);

                // Apply Brightness
                let imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
                let data = imageData.data;
                const brightnessVal = parseInt(brightness.value);
                if (brightnessVal !== 0) {
                    for (let i = 0; i < data.length; i += 4) {
                        data[i] = Math.max(0, Math.min(255, data[i] + brightnessVal));
                        data[i+1] = Math.max(0, Math.min(255, data[i+1] + brightnessVal));
                        data[i+2] = Math.max(0, Math.min(255, data[i+2] + brightnessVal));
                    }
                    tempCtx.putImageData(imageData, 0, 0);
                }

                // Apply Contrast
                imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
                data = imageData.data;
                const contrastVal = (parseInt(contrast.value) + 100) / 100;
                if (contrastVal !== 1) {
                    for (let i = 0; i < data.length; i += 4) {
                        data[i] = Math.max(0, Math.min(255, ((data[i] / 255 - 0.5) * contrastVal + 0.5) * 255));
                        data[i+1] = Math.max(0, Math.min(255, ((data[i+1] / 255 - 0.5) * contrastVal + 0.5) * 255));
                        data[i+2] = Math.max(0, Math.min(255, ((data[i+2] / 255 - 0.5) * contrastVal + 0.5) * 255));
                    }
                    tempCtx.putImageData(imageData, 0, 0);
                }

                // Apply Saturation
                imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
                data = imageData.data;
                const saturationVal = (parseInt(saturation.value) + 100) / 100;
                if (saturationVal !== 1) {
                    for (let i = 0; i < data.length; i += 4) {
                        const r = data[i] / 255;
                        const g = data[i+1] / 255;
                        const b = data[i+2] / 255;
                        const luma = r * 0.299 + g * 0.587 + b * 0.114;
                        data[i] = Math.max(0, Math.min(255, (luma + (r - luma) * saturationVal) * 255));
                        data[i+1] = Math.max(0, Math.min(255, (luma + (g - luma) * saturationVal) * 255));
                        data[i+2] = Math.max(0, Math.min(255, (luma + (b - luma) * saturationVal) * 255));
                    }
                    tempCtx.putImageData(imageData, 0, 0);
                }

                // Apply Hue Shift
                imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
                data = imageData.data;
                const hueShiftVal = parseInt(hueShift.value) * Math.PI / 180;
                if (hueShiftVal !== 0) {
                    for (let i = 0; i < data.length; i += 4) {
                        let r = data[i] / 255;
                        let g = data[i+1] / 255;
                        let b = data[i+2] / 255;
                        // Convert RGB to HSL
                        const max = Math.max(r, g, b);
                        const min = Math.min(r, g, b);
                        let h, s, l = (max + min) / 2;
                        if (max === min) {
                            h = s = 0; // achromatic
                        } else {
                            const d = max - min;
                            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                            switch (max) {
                                case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                                case g: h = (b - r) / d + 2; break;
                                case b: h = (r - g) / d + 4; break;
                            }
                            h /= 6;
                        }
                        // Apply hue shift
                        h = (h + hueShiftVal / (2 * Math.PI) + 1) % 1;
                        // Convert HSL back to RGB
                        let rgb;
                        if (s === 0) {
                            r = g = b = l; // achromatic
                        } else {
                            const hue2rgb = (p, q, t) => {
                                if (t < 0) t += 1;
                                if (t > 1) t -= 1;
                                if (t < 1/6) return p + (q - p) * 6 * t;
                                if (t < 1/2) return q;
                                if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                                return p;
                            };
                            const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                            const p = 2 * l - q;
                            r = hue2rgb(p, q, h + 1/3);
                            g = hue2rgb(p, q, h);
                            b = hue2rgb(p, q, h - 1/3);
                        }
                        data[i] = Math.max(0, Math.min(255, r * 255));
                        data[i+1] = Math.max(0, Math.min(255, g * 255));
                        data[i+2] = Math.max(0, Math.min(255, b * 255));
                    }
                    tempCtx.putImageData(imageData, 0, 0);
                }

                // Apply Highlights and Shadows
                imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
                data = imageData.data;
                const highlightsVal = parseInt(highlights.value) / 100;
                const shadowsVal = parseInt(shadows.value) / 100;
                if (highlightsVal !== 0 || shadowsVal !== 0) {
                    for (let i = 0; i < data.length; i += 4) {
                        let r = data[i] / 255;
                        let g = data[i+1] / 255;
                        let b = data[i+2] / 255;
                        const luma = r * 0.299 + g * 0.587 + b * 0.114;
                        if (highlightsVal !== 0 && luma > 0.5) {
                            const factor = highlightsVal * (luma - 0.5) * 2;
                            r += factor;
                            g += factor;
                            b += factor;
                        }
                        if (shadowsVal !== 0 && luma < 0.5) {
                            const factor = shadowsVal * (0.5 - luma) * 2;
                            r += factor;
                            g += factor;
                            b += factor;
                        }
                        data[i] = Math.max(0, Math.min(255, r * 255));
                        data[i+1] = Math.max(0, Math.min(255, g * 255));
                        data[i+2] = Math.max(0, Math.min(255, b * 255));
                    }
                    tempCtx.putImageData(imageData, 0, 0);
                }

                // Apply Greyscale
                if (greyscaleToggle.checked) {
                    imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
                    data = imageData.data;
                    for (let i = 0; i < data.length; i += 4) {
                        const grey = data[i] * 0.299 + data[i+1] * 0.587 + data[i+2] * 0.114;
                        data[i] = grey;
                        data[i+1] = grey;
                        data[i+2] = grey;
                    }
                    tempCtx.putImageData(imageData, 0, 0);
                }

                // Apply Sharpen
                imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
                data = imageData.data;
                const sharpenVal = parseFloat(sharpen.value);
                if (sharpenVal > 0) {
                    const weights = [0, -1, 0, -1, 5 + sharpenVal, -1, 0, -1, 0];
                    const side = Math.round(Math.sqrt(weights.length));
                    const halfSide = Math.floor(side / 2);
                    const src = new Uint8ClampedArray(data);
                    const w = tempCanvas.width;
                    const h = tempCanvas.height;
                    for (let y = 0; y < h; y++) {
                        for (let x = 0; x < w; x++) {
                            const dstIdx = (y * w + x) * 4;
                            let r = 0, g = 0, b = 0;
                            for (let cy = 0; cy < side; cy++) {
                                for (let cx = 0; cx < side; cx++) {
                                    const scy = y + cy - halfSide;
                                    const scx = x + cx - halfSide;
                                    if (scy >= 0 && scy < h && scx >= 0 && scx < w) {
                                        const srcIdx = (scy * w + scx) * 4;
                                        const wt = weights[cy * side + cx];
                                        r += src[srcIdx] * wt;
                                        g += src[srcIdx + 1] * wt;
                                        b += src[srcIdx + 2] * wt;
                                    }
                                }
                            }
                            data[dstIdx] = Math.max(0, Math.min(255, r));
                            data[dstIdx + 1] = Math.max(0, Math.min(255, g));
                            data[dstIdx + 2] = Math.max(0, Math.min(255, b));
                        }
                    }
                    tempCtx.putImageData(imageData, 0, 0);
                }

                // Apply Darken Lines
                if (darkenLinesEnabled.checked) {
                    imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
                    data = imageData.data;
                    const threshold = parseInt(darkenThreshold.value);
                    for (let i = 0; i < data.length; i += 4) {
                        const brightness = (data[i] + data[i+1] + data[i+2]) / 3;
                        if (brightness > threshold) data[i+3] = 0;
                    }
                    tempCtx.putImageData(imageData, 0, 0);
                    const layers = parseInt(darkenLayers.value);
                    for (let i = 1; i < layers; i++) {
                        tempCtx.globalCompositeOperation = 'multiply';
                        tempCtx.drawImage(tempCanvas, 0, 0);
                    }
                    tempCtx.globalCompositeOperation = 'source-over';
                }

                // Pixelize if needed
                let imageToDraw = tempCanvas;
                const pixelSizeVal = parseInt(pixelSize.value);
                if (pixelSizeVal > 1) {
                    const smallWidth = Math.ceil(baseCanvas.width / pixelSizeVal);
                    const smallHeight = Math.ceil(baseCanvas.height / pixelSizeVal);
                    const smallCanvas = document.createElement('canvas');
                    smallCanvas.width = smallWidth;
                    smallCanvas.height = smallHeight;
                    const smallCtx = smallCanvas.getContext('2d');
                    smallCtx.drawImage(tempCanvas, 0, 0, smallWidth, smallHeight);
                    imageToDraw = smallCanvas;
                }

                // Draw to Main Canvas with Final Blur
                ctx.filter = `blur(${parseFloat(blurSlider.value)}px)`;
                ctx.imageSmoothingEnabled = false; // For pixelated look when scaling
                ctx.drawImage(imageToDraw, 0, 0, width, height);
                ctx.imageSmoothingEnabled = true;
                ctx.filter = 'none';

                // Apply Noise
                if (noiseEnabled.checked) {
                    const noiseCanvas = document.createElement('canvas');
                    noiseCanvas.width = width;
                    noiseCanvas.height = height;
                    const noiseCtx = noiseCanvas.getContext('2d');
                    const noiseData = noiseCtx.createImageData(width, height);
                    const nR = parseInt(noiseR.value) * 2.55;
                    const nG = parseInt(noiseG.value) * 2.55;
                    const nB = parseInt(noiseB.value) * 2.55;
                    const size = parseInt(noiseSize.value);
                    for (let y = 0; y < height; y += size) {
                        for (let x = 0; x < width; x += size) {
                            const r = Math.random() * nR * 2 - nR;
                            const g = Math.random() * nG * 2 - nG;
                            const b = Math.random() * nB * 2 - nB;
                            for (let sy = 0; sy < size && y + sy < height; sy++) {
                                for (let sx = 0; sx < size && x + sx < width; sx++) {
                                    const idx = ((y + sy) * width + (x + sx)) * 4;
                                    noiseData.data[idx] = r;
                                    noiseData.data[idx+1] = g;
                                    noiseData.data[idx+2] = b;
                                    noiseData.data[idx+3] = 255;
                                }
                            }
                        }
                    }
                    noiseCtx.putImageData(noiseData, 0, 0);
                    ctx.filter = `blur(${parseFloat(noiseBlur.value)}px)`;
                    ctx.globalCompositeOperation = 'overlay';
                    ctx.drawImage(noiseCanvas, 0, 0);
                    ctx.globalCompositeOperation = 'source-over';
                    ctx.filter = 'none';
                }

                // Apply Color Overlay
                ctx.globalAlpha = parseInt(overlayOpacity.value) / 100;
                ctx.fillStyle = overlayColor.value;
                ctx.fillRect(0, 0, width, height);
                ctx.globalAlpha = 1;

                // Draw Shapes with Blur if enabled
                if (shapesEnabled.checked && shapesData.length > 0) {
                    const shapesCanvas = document.createElement('canvas');
                    shapesCanvas.width = width;
                    shapesCanvas.height = height;
                    const shapesCtx = shapesCanvas.getContext('2d');
                    shapesCtx.filter = `blur(${parseFloat(shapesBlur.value)}px)`;
                    shapesData.forEach(shape => {
                        shapesCtx.globalAlpha = shape.opacity;
                        shapesCtx.fillStyle = shape.color;
                        shapesCtx.beginPath();
                        if (shape.type === 'circle') {
                            shapesCtx.arc(shape.x, shape.y, shape.size / 2, 0, 2 * Math.PI);
                        } else if (shape.type === 'square') {
                            shapesCtx.rect(shape.x - shape.size / 2, shape.y - shape.size / 2, shape.size, shape.size);
                        } else if (shape.type === 'triangle') {
                            shapesCtx.moveTo(shape.x, shape.y - shape.size / 2);
                            shapesCtx.lineTo(shape.x - shape.size / 2, shape.y + shape.size / 2);
                            shapesCtx.lineTo(shape.x + shape.size / 2, shape.y + shape.size / 2);
                            shapesCtx.closePath();
                        }
                        shapesCtx.fill();
                    });
                    shapesCtx.globalAlpha = 1;
                    ctx.drawImage(shapesCanvas, 0, 0);
                }
            }

            // Bucket Fill Tool
            function bucketFill(e) {
                const rect = mainCanvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                const scaleX = baseCanvas.width / rect.width;
                const scaleY = baseCanvas.height / rect.height;
                const baseX = Math.floor(x * scaleX);
                const baseY = Math.floor(y * scaleY);
                const imageData = baseCtx.getImageData(0, 0, baseCanvas.width, baseCanvas.height);
                const data = imageData.data;
                const pixel = baseY * baseCanvas.width + baseX;
                const startColor = [data[pixel*4], data[pixel*4+1], data[pixel*4+2]];
                const fillColor = hexToRgb(bucketColor.value);
                if (colorsEqual(startColor, fillColor)) return;
                const threshold = parseInt(bucketThreshold.value);
                const opacity = parseInt(bucketOpacity.value) / 100;
                const queue = [pixel];
                const visited = new Set();
                while (queue.length) {
                    const p = queue.shift();
                    if (visited.has(p)) continue;
                    visited.add(p);
                    const px = p % baseCanvas.width;
                    const py = Math.floor(p / baseCanvas.width);
                    const idx = (py * baseCanvas.width + px) * 4;
                    const currentColor = [data[idx], data[idx+1], data[idx+2]];
                    if (colorDistance(startColor, currentColor) <= threshold) {
                        data[idx] = fillColor[0];
                        data[idx+1] = fillColor[1];
                        data[idx+2] = fillColor[2];
                        data[idx+3] = Math.round(opacity * 255); // Apply opacity
                        if (px > 0) queue.push(p - 1);
                        if (px < baseCanvas.width - 1) queue.push(p + 1);
                        if (py > 0) queue.push(p - baseCanvas.width);
                        if (py < baseCanvas.height - 1) queue.push(p + baseCanvas.width);
                    }
                }
                baseCtx.putImageData(imageData, 0, 0);
                addToHistory('Bucket Fill', baseCanvas.toDataURL());
                render();
            }

            // Paintbrush Tool
            function startPaint(e) {
                isPainting = true;
                const rect = mainCanvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                const scaleX = baseCanvas.width / rect.width;
                const scaleY = baseCanvas.height / rect.height;
                const baseX = x * scaleX;
                const baseY = y * scaleY;
                baseCtx.beginPath();
                baseCtx.moveTo(baseX, baseY);
                baseCtx.strokeStyle = paintbrushColor.value;
                const brushSize = parseInt(paintbrushSize.value);
                baseCtx.lineWidth = brushSize * (baseCanvas.width / rect.width);
                baseCtx.lineCap = 'round';
                baseCtx.lineJoin = 'round';
                baseCtx.globalAlpha = parseInt(paintbrushOpacity.value) / 100;
            }

            function paint(e) {
                if (!isPainting) return;
                const rect = mainCanvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                const scaleX = baseCanvas.width / rect.width;
                const scaleY = baseCanvas.height / rect.height;
                const baseX = x * scaleX;
                const baseY = y * scaleY;
                baseCtx.lineTo(baseX, baseY);
                baseCtx.stroke();
                render();
            }

            function stopPaint() {
                if (isPainting) {
                    isPainting = false;
                    baseCtx.globalAlpha = 1; // Reset for other operations
                    addToHistory('Paintbrush Stroke', baseCanvas.toDataURL());
                }
            }

            // Video Loading
            function loadVideo(file) {
                const url = URL.createObjectURL(file);
                videoPlayer.src = url;
                videoPlayer.style.display = 'block';
                videoDropZone.style.display = 'none';
                videoCanvas.style.display = 'none';
                videoControls.style.display = 'block';
                videoLoaded = true;

                videoPlayer.addEventListener('loadedmetadata', () => {
                    frameRate = 30; // Approximation; HTML5 doesnt provide exact frame rate easily
                    videoSeek.max = videoPlayer.duration * frameRate;
                    frameNumber.max = videoSeek.max;
                });

                videoPlayer.addEventListener('timeupdate', () => {
                    videoSeek.value = videoPlayer.currentTime * frameRate;
                    frameNumber.value = Math.round(videoSeek.value);
                });
            }

            videoDropZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                videoDropZone.classList.add('dragover');
            });
            videoDropZone.addEventListener('dragleave', () => videoDropZone.classList.remove('dragover'));
            videoDropZone.addEventListener('drop', (e) => {
                e.preventDefault();
                videoDropZone.classList.remove('dragover');
                const file = e.dataTransfer.files[0];
                if (file && file.type === 'video/mp4') loadVideo(file);
            });
            videoDropZone.addEventListener('click', () => {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = 'video/mp4';
                input.onchange = (e) => loadVideo(e.target.files[0]);
                input.click();
            });

            // Frame Extraction Functions
            async function captureFrame(time) {
                videoPlayer.currentTime = time;
                return new Promise(resolve => {
                    videoPlayer.onseeked = () => {
                        videoCanvas.width = videoPlayer.videoWidth;
                        videoCanvas.height = videoPlayer.videoHeight;
                        videoCtx.drawImage(videoPlayer, 0, 0);
                        const dataUrl = videoCanvas.toDataURL('image/png');
                        resolve(dataUrl);
                        videoPlayer.onseeked = null;
                    };
                });
            }

            async function saveFrameToDirectory(time, dataUrl) {
                if (!saveDirectoryHandle || !saveToDir.checked) return;
                const fileName = `frame_${time.toFixed(2).replace('.', '_')}.png`;
                const fileHandle = await saveDirectoryHandle.getFileHandle(fileName, { create: true });
                const writable = await fileHandle.createWritable();
                const blob = await (await fetch(dataUrl)).blob();
                await writable.write(blob);
                await writable.close();
            }

            function addFrameToList(time, dataUrl) {
                const frameItem = document.createElement('div');
                frameItem.textContent = `Frame @ ${time.toFixed(2)}s`;
                const img = document.createElement('img');
                img.src = dataUrl;
                img.style.width = '50px';
                img.style.cursor = 'pointer';
                img.onclick = () => {
                    const fullImg = new Image();
                    fullImg.onload = () => {
                        originalImage = fullImg;
                        originalImageData = dataUrl; // Update original for reset
                        baseCanvas.width = fullImg.width;
                        baseCanvas.height = fullImg.height;
                        baseCtx.drawImage(fullImg, 0, 0);
                        const gcd = (a, b) => b === 0 ? a : gcd(b, a % b);
                        const divisor = gcd(baseCanvas.width, baseCanvas.height);
                        document.getElementById('originalInfo').textContent = `${baseCanvas.width}x${baseCanvas.height} (${baseCanvas.width / divisor}:${baseCanvas.height / divisor})`;
                        widthInput.value = baseCanvas.width;
                        heightInput.value = baseCanvas.height;
                        addToHistory('Load Frame', baseCanvas.toDataURL());
                        imageDropZone.style.display = 'none'; // Hide drop zone
                        render();
                        document.querySelector('.tab[data-tab="image"]').click();
                    };
                    fullImg.src = dataUrl;
                };
                frameItem.appendChild(img);
                frameList.appendChild(frameItem);
                frameList.scrollTop = frameList.scrollHeight;
            }

            chooseSaveDir.addEventListener('click', async () => {
                try {
                    saveDirectoryHandle = await window.showDirectoryPicker();
                    saveDirInfo.textContent = `Saving to: ${saveDirectoryHandle.name}`;
                } catch (e) {
                    console.error('Directory selection failed:', e);
                    saveDirInfo.textContent = 'Failed to select directory';
                }
            });

            extractLastFrame.addEventListener('click', async () => {
                if (!videoLoaded) return;
                const lastTime = videoPlayer.duration - 0.01;
                const dataUrl = await captureFrame(lastTime);
                if (saveToDir.checked && saveDirectoryHandle) await saveFrameToDirectory(lastTime, dataUrl);
                addFrameToList(lastTime, dataUrl);
            });

            extractAllFrames.addEventListener('click', async () => {
                if (!videoLoaded) return;
                const duration = videoPlayer.duration;
                const totalFrames = Math.floor(duration * frameRate);
                for (let i = 0; i < totalFrames; i++) {
                    const time = i / frameRate;
                    const dataUrl = await captureFrame(time);
                    if (saveToDir.checked && saveDirectoryHandle) await saveFrameToDirectory(time, dataUrl);
                    addFrameToList(time, dataUrl);
                }
            });

            extractInterval.addEventListener('click', async () => {
                if (!videoLoaded) return;
                const interval = parseFloat(intervalValue.value);
                const duration = videoPlayer.duration;
                if (intervalType.value === 'frame') {
                    const step = Math.max(1, Math.floor(interval));
                    const totalFrames = Math.floor(duration * frameRate);
                    for (let i = 0; i < totalFrames; i += step) {
                        const time = i / frameRate;
                        const dataUrl = await captureFrame(time);
                        if (saveToDir.checked && saveDirectoryHandle) await saveFrameToDirectory(time, dataUrl);
                        addFrameToList(time, dataUrl);
                    }
                } else { // time
                    for (let time = 0; time < duration; time += interval) {
                        const dataUrl = await captureFrame(time);
                        if (saveToDir.checked && saveDirectoryHandle) await saveFrameToDirectory(time, dataUrl);
                        addFrameToList(time, dataUrl);
                    }
                }
            });

            extractCurrentFrame.addEventListener('click', async () => {
                if (!videoLoaded) return;
                const frame = parseInt(frameNumber.value);
                const time = frame / frameRate;
                const dataUrl = await captureFrame(time);
                if (saveToDir.checked && saveDirectoryHandle) await saveFrameToDirectory(time, dataUrl);
                addFrameToList(time, dataUrl);
            });

            videoSeek.addEventListener('input', () => {
                if (!videoLoaded) return;
                const frame = parseInt(videoSeek.value);
                videoPlayer.currentTime = frame / frameRate;
                frameNumber.value = frame;
            });

            frameNumber.addEventListener('input', () => {
                if (!videoLoaded) return;
                const frame = parseInt(frameNumber.value);
                videoPlayer.currentTime = frame / frameRate;
                videoSeek.value = frame;
            });

            closeImageBtn.addEventListener('click', closeImage);
            closeVideoBtn.addEventListener('click', closeVideo);

            // Helper Functions
            function hexToRgb(hex) {
                return [
                    parseInt(hex.slice(1, 3), 16),
                    parseInt(hex.slice(3, 5), 16),
                    parseInt(hex.slice(5, 7), 16)
                ];
            }
            function colorsEqual(c1, c2) {
                return c1[0] === c2[0] && c1[1] === c2[1] && c1[2] === c2[2];
            }
            function colorDistance(c1, c2) {
                return Math.sqrt((c1[0] - c2[0])**2 + (c1[1] - c2[1])**2 + (c1[2] - c2[2])**2);
            }

            // Slider Sync Function
            function syncSlider(slider, valueInput, callback = render) {
                const update = () => {
                    valueInput.value = slider.value;
                    if (liveUpdates.checked) callback();
                };
                slider.addEventListener('input', update);
                valueInput.addEventListener('input', () => {
                    slider.value = valueInput.value;
                    if (liveUpdates.checked) callback();
                });
                return update;
            }

            // Uniform RGB Logic
            function updateUniformRGB(changedSlider) {
                if (uniformRGB.checked) {
                    const value = changedSlider.value;
                    noiseR.value = value;
                    noiseG.value = value;
                    noiseB.value = value;
                    noiseRValue.value = value;
                    noiseGValue.value = value;
                    noiseBValue.value = value;
                    if (liveUpdates.checked) render();
                }
            }

            noiseR.addEventListener('input', () => updateUniformRGB(noiseR));
            noiseG.addEventListener('input', () => updateUniformRGB(noiseG));
            noiseB.addEventListener('input', () => updateUniformRGB(noiseB));

            // Event Listeners for Buttons
            undoBtn.addEventListener('click', undo);
            undoBottomBtn.addEventListener('click', undo);
            resetBtn.addEventListener('click', resetImage);
            saveBtn.addEventListener('click', () => window.open(mainCanvas.toDataURL('image/png')));
            saveAsBtn.addEventListener('click', () => {
                const link = document.createElement('a');
                link.download = 'image.png';
                link.href = mainCanvas.toDataURL('image/png');
                link.click();
            });

            // Sync Sliders
            syncSlider(brightness, brightnessValue);
            syncSlider(sharpen, sharpenValue);
            syncSlider(saturation, saturationValue);
            syncSlider(contrast, contrastValue);
            syncSlider(highlights, highlightsValue);
            syncSlider(shadows, shadowsValue);
            syncSlider(hueShift, hueShiftValue);
            greyscaleToggle.addEventListener('change', () => { if (liveUpdates.checked) render(); });
            syncSlider(blurSlider, blurValue);
            syncSlider(noiseR, noiseRValue);
            syncSlider(noiseG, noiseGValue);
            syncSlider(noiseB, noiseBValue);
            syncSlider(noiseSize, noiseSizeValue);
            syncSlider(noiseBlur, noiseBlurValue);
            syncSlider(overlayOpacity, overlayOpacityValue);
            syncSlider(shapesCount, shapesCountValue, () => { generateShapes(); render(); });
            syncSlider(shapesSize, shapesSizeValue, () => { generateShapes(); render(); });
            syncSlider(shapesOpacity, shapesOpacityValue, () => { generateShapes(); render(); });
            syncSlider(shapesBlur, shapesBlurValue);
            syncSlider(darkenThreshold, darkenThresholdValue);
            syncSlider(darkenLayers, darkenLayersValue);
            syncSlider(bucketThreshold, bucketThresholdValue);
            syncSlider(bucketOpacity, bucketOpacityValue);
            syncSlider(paintbrushSize, paintbrushSizeValue);
            syncSlider(paintbrushOpacity, paintbrushOpacityValue);
            syncSlider(pixelSize, pixelSizeValue);

            // Shape Input Listeners
            const shapeInputs = [
                shapesCircle, shapesSquare, shapesTriangle,
                shapesRandomSize, shapesRandomRotation,
                shapesRandomColorSimilar, shapesRandomColorTrue, shapesRandomOpacity,
                shapesGridEnabled, shapesGridCols, shapesGridRows,
                shapesColor, shapesEnabled
            ];
            shapeInputs.forEach(input => {
                input.addEventListener('change', () => {
                    if (input === shapesRandomColorSimilar && shapesRandomColorSimilar.checked) {
                        shapesRandomColorTrue.checked = false;
                    } else if (input === shapesRandomColorTrue && shapesRandomColorTrue.checked) {
                        shapesRandomColorSimilar.checked = false;
                    }
                    generateShapes();
                    if (liveUpdates.checked) render();
                });
            });

            // Tool Selection Logic
            document.querySelectorAll('input[name="tool"]').forEach(radio => {
                radio.addEventListener('change', () => {
                    document.getElementById('bucketSettings').style.display = radio.value === 'bucket' ? 'block' : 'none';
                    document.getElementById('paintbrushSettings').style.display = radio.value === 'paintbrush' ? 'block' : 'none';
                    mainCanvas.removeEventListener('click', bucketFill);
                    mainCanvas.removeEventListener('mousedown', startPaint);
                    mainCanvas.removeEventListener('mousemove', paint);
                    mainCanvas.removeEventListener('mouseup', stopPaint);
                    mainCanvas.removeEventListener('mouseleave', stopPaint);
                    if (radio.value === 'bucket') {
                        mainCanvas.addEventListener('click', bucketFill);
                    } else if (radio.value === 'paintbrush') {
                        mainCanvas.addEventListener('mousedown', startPaint);
                        mainCanvas.addEventListener('mousemove', paint);
                        mainCanvas.addEventListener('mouseup', stopPaint);
                        mainCanvas.addEventListener('mouseleave', stopPaint);
                    }
                });
            });
        </script>
    </body>
</html>
